// <copyright file="NativeHashMapDataImposter.cs" company="BovineLabs">
//     Copyright (c) BovineLabs. All rights reserved.
// </copyright>
// <auto-generated>It's not, just don't want analyzers working on this file atm.</auto-generated>

namespace BovineLabs.Common.Collections
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.InteropServices;
#if UNITY_2019_3_OR_NEWER
    using Unity.Collections.LowLevel.Unsafe;
#endif
    using Unity.Jobs.LowLevel.Unsafe;

    [StructLayout(LayoutKind.Explicit)]
    internal unsafe struct NativeHashMapDataImposter
    {
        [FieldOffset(0)]
        public byte* Values;

        [FieldOffset(8)]
        public byte* Keys;

        [FieldOffset(16)]
        public byte* Next;

        [FieldOffset(24)]
        public byte* Buckets;

        [FieldOffset(32)]
        public int KeyCapacity;

        [FieldOffset(36)]
        public int BucketCapacityMask; // = bucket capacity - 1

        [FieldOffset(40)]
        public int AllocatedIndexLength;

        // ReSharper disable once UnreachableCode
        [FieldOffset(JobsUtility.CacheLineSize < 64 ? 64 : JobsUtility.CacheLineSize)]
        public fixed int FirstFreeTLS[JobsUtility.MaxJobThreadCount * IntsPerCacheLine];

        // 64 is the cache line size on x86, arm usually has 32 - so it is possible to save some memory there
        public const int IntsPerCacheLine = JobsUtility.CacheLineSize / sizeof(int);

#if UNITY_2019_3_OR_NEWER
        public static void Clear(NativeHashMapDataImposter* data)
        {
            UnsafeUtility.MemSet(
                data->Buckets,
                byte.MaxValue,
                (data->BucketCapacityMask + 1) * UnsafeUtility.SizeOf<int>());

            UnsafeUtility.MemSet(
                data->Next,
                byte.MaxValue,
                data->KeyCapacity * UnsafeUtility.SizeOf<int>());

            UnsafeUtility.MemSet(
                data->FirstFreeTLS,
                byte.MaxValue,
                JobsUtility.MaxJobThreadCount * IntsPerCacheLine * UnsafeUtility.SizeOf<int>());

            data->AllocatedIndexLength = 0;
        }
#endif

        public static void Clone<TKey, TValue>(NativeHashMapDataImposter* from, NativeHashMapDataImposter* to)
            where TKey : struct, IEquatable<TKey> where TValue : struct
        {
            CalculateDataSize<TKey, TValue>(
                from->KeyCapacity,
                from->BucketCapacityMask + 1,
                out var keyOffset,
                out var nextOffset,
                out var bucketOffset);

            to->KeyCapacity = from->KeyCapacity;
            to->BucketCapacityMask = from->BucketCapacityMask;
            to->AllocatedIndexLength = from->AllocatedIndexLength;

            UnsafeUtility.MemCpy(to->Values, from->Values, keyOffset * UnsafeUtility.SizeOf<TValue>());
            UnsafeUtility.MemCpy(to->Keys, from->Keys, nextOffset * UnsafeUtility.SizeOf<TKey>());
            UnsafeUtility.MemCpy(to->Next, from->Next, bucketOffset * UnsafeUtility.SizeOf<int>());
            UnsafeUtility.MemCpy(to->Buckets, from->Buckets,
                (from->BucketCapacityMask + 1) * UnsafeUtility.SizeOf<int>());

            UnsafeUtility.MemCpy(
                to->FirstFreeTLS,
                from->FirstFreeTLS,
                JobsUtility.MaxJobThreadCount * NativeHashMapDataImposter.IntsPerCacheLine *
                UnsafeUtility.SizeOf<int>());
        }

        [SuppressMessage("ReSharper", "UnusedMethodReturnValue.Local")]
        private static int CalculateDataSize<TKey, TValue>(int length, int bucketLength, out int keyOffset,
            out int nextOffset, out int bucketOffset)
            where TKey : struct, IEquatable<TKey>
            where TValue : struct
        {
            int elementSize = UnsafeUtility.SizeOf<TValue>();
            int keySize = UnsafeUtility.SizeOf<TKey>();

            // Offset is rounded up to be an even cacheLineSize
            keyOffset = (elementSize * length + JobsUtility.CacheLineSize - 1);
            keyOffset -= keyOffset % JobsUtility.CacheLineSize;

            nextOffset = (keyOffset + keySize * length + JobsUtility.CacheLineSize - 1);
            nextOffset -= nextOffset % JobsUtility.CacheLineSize;

            bucketOffset = (nextOffset + UnsafeUtility.SizeOf<int>() * length + JobsUtility.CacheLineSize - 1);
            bucketOffset -= bucketOffset % JobsUtility.CacheLineSize;

            int totalSize = bucketOffset + UnsafeUtility.SizeOf<int>() * bucketLength;
            return totalSize;
        }
    }
}
